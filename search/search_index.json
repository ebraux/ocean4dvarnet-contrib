{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Contributions pour le package ocean4dvarnet","text":"<p>Ce package contient un ensemble de contributions additionnelles pour le package ocean4dvarnet</p> <ul> <li>Liste des contributions</li> <li>Pour d\u00e9velopper une nouvelle contribution</li> </ul>"},{"location":"about/","title":"About","text":""},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for your interest to contrute to the Ocean 4DVarNet model</p>"},{"location":"contributing/#raise-an-issue","title":"Raise an issue","text":"<p>If you are using a contribution, and encounter a bug or have a feature request, the first step is to let us know by raising an issue on GitHub using the following steps:</p> <ul> <li>Check the existing issues to avoid duplicates.</li> <li>If it's a new issue, create a detailed bug report or feature request by filling in the issue template.</li> <li>Use clear, descriptive titles and provide as much relevant information as possible.</li> <li>If you have a bug, include the steps to reproduce it.</li> <li>If you have a feature request, describe the use case and expected behaviour.</li> <li>If you are interested in solving the issue yourself, assign the issue to yourself and follow the steps below.</li> </ul>"},{"location":"contributing/#contributing-to-the-development","title":"Contributing to the development","text":"<p>For contributing to the development of the Anemoi packages, please follow these steps:</p> <ul> <li>Fork the ocean4dvarnet-contrib repository on GitHub to your personal/organisation    account. See the GitHub tutorial : https://docs.github.com/en/get-started/quickstart/fork-a-repo.</li> <li>Set up the development environment following the instructions in the setting-up-the-development-environment documentation.</li> <li>Create a new branch for your developments, following the <code>branching-guidelines</code>.</li> <li>Make your changes and ensure that your changes adhere to the <code>development-guidelines</code>.<ul> <li>To contribute to an existing contribution, make ypour change in the contribution code</li> <li>To add e new contribution, folleow the guide [create]</li> </ul> </li> <li>Commit your changes and push your branch to your fork on GitHub.</li> <li>Open a Pull Request against the <code>main</code> branch of the original repository, set a PR title according to the :ref:<code>pr-title-guidelines</code> and fill in the Pull Request template.</li> <li>Request a review from maintainers or other contributors, which will follow the [code-review-process]</li> </ul>"},{"location":"contributing/#code-review-process","title":"Code Review Process","text":"<p>The ocean4dvarnet-contrib packages have a set of automated checks to enforce coding guidelines. These checks are run via GitHub Actions on every Pull Request.</p> <p>For security reasons, maintainers must review code changes before enabling automated checks.</p> <ul> <li>Ensure that all the :ref:<code>development-guidelines</code> criteria are met before submitting a Pull Request.</li> <li>Request a review from maintainers or other contributors, noting that support is on a best-efforts basis.</li> <li>After an initial review, a maintainer will enable automated checks to run on the Pull Request.</li> <li>Reviewers may provide feedback or request changes to your contribution.</li> <li>Once approved, a maintainer will merge your Pull Request into the appropriate branch.</li> </ul>"},{"location":"contributing/#code-of-conduct","title":"Code of conduct","text":"<p>Please follow the GitHub Code of Conduct for respectful collaboration.</p>"},{"location":"init-new-contrib/","title":"Creating a New Contribution","text":"<p>Une  contribution doit contenir au minimum :</p> <pre><code>contrib/\n\u251c\u2500\u2500 &lt;CONTRIB_NAME&gt;\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 metadatas.yml\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 README.md\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 &lt;CONTRIB_NAME&gt;.py\n|   \u2514\u2500\u2500 tests/\n|      \u2514\u2500\u2500 test_&lt;CONTRIB_NAME&gt;.py\n</code></pre> <ul> <li><code>__init__.py</code> : fichier de configuration du module, peut \u00eatr vide</li> <li><code>metadatas.yml</code> : contient les information sur la contrinution, auteur, description, ...</li> <li><code>README.md</code></li> <li><code>&lt;CONTRIB_NAME&gt;.py</code> : votre code</li> <li>`test</li> </ul> <p>Il peut \u00e9galement contenir en plus :</p> <ul> <li><code>requirement.txt</code></li> <li><code>pyproject.toml</code></li> <li><code>LICENSE.md</code></li> <li>d'autres fichiers de code python</li> </ul> <p>Pour initialiser une nouvelle contribution, utiliser le script <code>init-new-contrib</code> <pre><code>python scripts/init-new-contrib.sh CONTRIB_NAME\n</code></pre></p> <p>Pour \u00eatre int\u00e9gr\u00e9 au d\u00e9p\u00f4t, la contribution sera \u00e9valu\u00e9 avec les outils de test de qualit\u00e9 de code (<code>pylint</code>, ...).</p> <p>Les test ne sont pas obligatoires, mais fortement recommand\u00e9s. Le code est test\u00e9 avec <code>pytest</code></p> <p>From the terminal, run the command: <pre><code>python3 scripts/init.py &lt;YOUR_CONTRIB_NAME&gt;\n</code></pre> The contribution name must only contain lowercase letters, digits, and underscores.</p> <p>If the name is valid, a folder will be created in <code>contrib</code> with the files <code>README.md</code> and <code>metadatas.yml</code>, initialized with default values.</p> <p>For example, if you enter : <pre><code>python3 scripts/init.py  example_contrib\n</code></pre> the script will create:</p> <ul> <li> <p><code>contrib/example_contrib/README.md</code> with the content: <pre><code># example_contrib\n</code></pre></p> </li> <li> <p><code>contrib/example_contrib/metadatas.yml</code> with the content: <pre><code>name: \"example_contrib\"\ndescription: \"example_contrib\"\ndate: \"2025-04-01\"\ncontact: \"contributor1@example.com\"\nversion: \"1.0.0\"\nlicense: \"CeCILL-C FREE SOFTWARE LICENSE AGREEMENT\"\ndependencies: \"\"\n</code></pre></p> </li> </ul>"},{"location":"setting-up-the-development-environment/","title":"Development Environment Set-up","text":"<p>To create a development environment follow the steps outlined below.</p>"},{"location":"setting-up-the-development-environment/#setting-up-your-fork","title":"Setting Up Your Fork","text":"<p>When working with a fork, follow these steps to set up your local development environment:</p> <ul> <li>Fork the repository: Create your own copy of the repository on GitHub, following this GitHub tutorial.</li> <li>Clone your fork: Download your forked repository to your local machine as outlined in this section of the tutorial.</li> <li>Add the upstream remote: Connect your local repository to the original repository to fetch updates as described in this section.</li> <li>Prevent accidental pushes to upstream: After setting up your fork and configuring the original repository as an upstream remote, it's a good practice to prevent accidental pushes to the upstream repository. You can do this by explicitly setting the push URL of the upstream remote to no_push. To do this, navigate to your local repository and run: <pre><code>git remote set-url --push upstream no_push\n</code></pre></li> <li>Verify the change with: <pre><code>git remote -v\n</code></pre> You should see something like this: <pre><code>origin    https://github.com/your-username/repository.git (fetch)\norigin    https://github.com/your-username/repository.git (push)\nupstream  https://github.com/original-owner/repository.git (fetch)\nupstream  no_push (push)\n</code></pre> With this configuration, you can still fetch updates from the upstream repository but won\u2019t be able to accidentally push changes to it.</li> </ul>"},{"location":"setting-up-the-development-environment/#creating-your-virtual-environment","title":"Creating Your Virtual Environment","text":"<p>The ocean4dvarnet-contrib is an extension of the ocean4dvarnet package. ocean4dvarnet require a CUDA / pytorch / pytorch-lignthing environment.</p> <ul> <li>Create and activate  a virtual environment with a python<ul> <li>For a full <code>CUDA / pytorch / pytorch-lignthing</code> environment,  follow the ocean4dvarnet documenmentation.</li> <li>You can also use a virtual environment with a python version  &gt;=3.10, and &lt;3.12.</li> </ul> </li> <li>Navigate to the repository you cloned, to the contribution directory you want to install the dependencies. ie for contribution <code>my_contrib</code> navigate to : <pre><code>cd contrib/my_contrib\n</code></pre></li> <li>Install dependencies: <pre><code>pip install -r requirements.txt\n</code></pre></li> </ul>"},{"location":"contrib/","title":"Index of Contributions","text":"<ul> <li>lorenz63</li> <li>toto5</li> </ul>"},{"location":"contrib/lorenz63/","title":"lorenz63","text":"Key Value name lorenz63 description lorenz63 version 1.0.0 license CeCILL-C FREE SOFTWARE LICENSE AGREEMENT authors Contributor Name dependencies [] <ul> <li>lorenz63</li> <li>data</li> <li>models</li> </ul>"},{"location":"contrib/lorenz63/data/","title":"lorenz63.data","text":""},{"location":"contrib/lorenz63/data/#contrib.lorenz63.data.dyn_lorenz63","title":"<code>dyn_lorenz63(t, x, sigma=10.0, rho=28.0, beta=8.0 / 3)</code>","text":"<p>Lorenz-63 dynamical model.</p> Source code in <code>contrib/lorenz63/data.py</code> <pre><code>def dyn_lorenz63(t, x, sigma=10., rho=28., beta=8./3):\n    \"\"\" Lorenz-63 dynamical model. \"\"\"\n    x_1 = sigma*(x[1]-x[0])\n    x_2 = x[0]*(rho-x[2])-x[1]\n    x_3 = x[0]*x[1] - beta*x[2]\n    dx  = np.array([x_1, x_2, x_3])\n    return dx\n</code></pre>"},{"location":"contrib/lorenz63/models/","title":"lorenz63.models","text":""},{"location":"contrib/lorenz63/models/#contrib.lorenz63.models.RearrangedBilinAEPriorCost","title":"<code>RearrangedBilinAEPriorCost</code>","text":"<p>               Bases: <code>BilinAEPriorCost</code></p> <p>Wrapper around the base prior cost that allows for reshaping of the input batch Used to convert the lorenz timeseries into an \"image\" for reuse of conv2d layers</p> Source code in <code>contrib/lorenz63/models.py</code> <pre><code>class RearrangedBilinAEPriorCost(src.models.BilinAEPriorCost):\n    \"\"\"\n    Wrapper around the base prior cost that allows for reshaping of the input batch\n    Used to convert the lorenz timeseries into an \"image\" for reuse of conv2d layers\n    \"\"\"\n    def __init__(self, rearrange_from='b c t', rearrange_to='b t c ()', *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.rearrange_bef = rearrange_from + ' -&gt; ' + rearrange_to\n        self.rearrange_aft = rearrange_to + ' -&gt; ' + rearrange_from\n\n    def forward_ae(self, x):\n        x = einops.rearrange(x, self.rearrange_bef)\n        x = super().forward_ae(x)\n        x = einops.rearrange(x, self.rearrange_aft)\n        return x\n</code></pre>"},{"location":"contrib/lorenz63/models/#contrib.lorenz63.models.RearrangedConvLstmGradModel","title":"<code>RearrangedConvLstmGradModel</code>","text":"<p>               Bases: <code>ConvLstmGradModel</code></p> <p>Wrapper around the base grad model that allows for reshaping of the input batch Used to convert the lorenz timeseries into an \"image\" for reuse of conv2d layers</p> Source code in <code>contrib/lorenz63/models.py</code> <pre><code>class RearrangedConvLstmGradModel(src.models.ConvLstmGradModel):\n    \"\"\"\n    Wrapper around the base grad model that allows for reshaping of the input batch\n    Used to convert the lorenz timeseries into an \"image\" for reuse of conv2d layers\n    \"\"\"\n    def __init__(self, rearrange_from='b c t', rearrange_to='b t c ()', *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.rearrange_bef = rearrange_from + ' -&gt; ' + rearrange_to\n        self.rearrange_aft = rearrange_to + ' -&gt; ' + rearrange_from\n\n    def reset_state(self, inp):\n        inp = einops.rearrange(inp, self.rearrange_bef)\n        super().reset_state(inp)\n\n    def forward(self, x):\n        x = einops.rearrange(x, self.rearrange_bef)\n        x = super().forward(x)\n        x = einops.rearrange(x, self.rearrange_aft)\n        return x\n</code></pre>"},{"location":"contrib/toto5/","title":"toto5","text":"Key Value name toto5 description toto5 version 1.0.0 license CeCILL-C FREE SOFTWARE LICENSE AGREEMENT authors Contributor Name dependencies [] <ul> <li>toto5</li> </ul>"},{"location":"scripts/","title":"Scripts","text":"<p>Scripts module for managing contributions.</p> <p>This module contains scripts for:</p> <ul> <li>Initializing new contributions (<code>init.py</code>)</li> <li>Validating contribution metadata (<code>validate_contributions.py</code>)</li> <li>Creating README files for contributions (<code>create_readme.py</code>)</li> <li>Creating metadata files for contributions (<code>create_metadatas.py</code>)</li> </ul> <ul> <li>generate_contrib_docs</li> <li>init_contrib</li> <li>manage_contrib_list</li> <li>fix_contribs</li> <li>utils</li> </ul>"},{"location":"scripts/fix_contribs/","title":"fix_contribs","text":"<p>Module: fix_contribs</p> <p>This module provides functionality to ensure that necessary files and directories  exist for each contribution in a specified contributions directory. It automates  the creation of essential files such as <code>pyproject.toml</code>, <code>README.md</code>, <code>__init__.py</code>,  a main Python file, and test files for each subdirectory within the contributions  directory. Additionally, it ensures the presence of a <code>tests</code> directory for each  contribution.</p> <p>Functions:</p> Name Description <code>- create_files_for_contribs</code> <p>Ensures the existence of required files and directories  for each contribution subdirectory.</p> Usage <p>Run this script directly to automatically create or verify the required files  and directories for contributions in the specified <code>CONTRIB_DIR</code>.</p>"},{"location":"scripts/fix_contribs/#scripts.fix_contribs.create_files_for_contribs","title":"<code>create_files_for_contribs()</code>","text":"<p>Ensures that necessary files and directories exist for each contribution  in the specified contributions directory.</p> <p>This function performs the following tasks for each subdirectory in the  contributions directory: - Checks if a <code>pyproject.toml</code> file exists; if not, creates one. - Checks if a <code>README.md</code> file exists; if not, creates one. - Checks if an <code>__init__.py</code> file exists; if not, creates one. - Checks if a main Python file named after the subdirectory exists; if not, creates one. - Creates a <code>tests</code> directory if it does not already exist. - Checks if a test file named <code>test_&lt;subdir&gt;.py</code> exists in the <code>tests</code> directory; if not, creates one.</p> <p>If any of the above files or directories already exist, a message is printed  indicating their presence.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scripts/fix_contribs.py</code> <pre><code>def create_files_for_contribs() -&gt; None:\n    \"\"\"\n    Ensures that necessary files and directories exist for each contribution \n    in the specified contributions directory.\n\n    This function performs the following tasks for each subdirectory in the \n    contributions directory:\n    - Checks if a `pyproject.toml` file exists; if not, creates one.\n    - Checks if a `README.md` file exists; if not, creates one.\n    - Checks if an `__init__.py` file exists; if not, creates one.\n    - Checks if a main Python file named after the subdirectory exists; if not, creates one.\n    - Creates a `tests` directory if it does not already exist.\n    - Checks if a test file named `test_&lt;subdir&gt;.py` exists in the `tests` directory; if not, creates one.\n\n    If any of the above files or directories already exist, a message is printed \n    indicating their presence.\n\n    Returns:\n        None\n    \"\"\"\n\n    if not os.path.exists(CONTRIB_DIR):\n        print(f\" The directory '{CONTRIB_DIR}' does not exist.\")\n        return\n\n    for subdir in list_subdirs(CONTRIB_DIR):\n        path = os.path.join(CONTRIB_DIR, subdir)\n\n        # Create the tests directory if it doesn't exist\n        create_tests_directory(contrib_path=path)\n\n        # Define file-checking tasks and their corresponding creation functions\n        tasks = [\n            (pyproject_file_exists, write_pyproject_file, \"pyproject.toml\", {'contrib_path': path}),\n            (readme_exists, create_readme, \"README.md\", {'contrib_path': path}),\n            (init_py_exists, create_init_py, \"__init__.py\", {'contrib_path': path}),\n            (main_py_exists, create_main_py, f\"{subdir}.py\", {'contrib_path': path, 'name': subdir}),\n            (test_file_exists, create_test_file, f\"test_{subdir}.py\", {'contrib_path': path, 'name': subdir}),\n            (conftest_file_exists, create_conftest_file, \"conftest.py\", {'contrib_path': path}),\n        ]\n\n        # Perform tasks for each file\n        for check_func, create_func, file_name, params in tasks:\n            if not check_func(**params):\n                create_func(**params)\n            else:\n                print(f\" {file_name} already exists in {path}/{subdir}\")\n</code></pre>"},{"location":"scripts/generate_contrib_docs/","title":"generate_contrib_docs","text":"<p>This script generates Markdown documentation for a specific subdirectory inside the 'contrib' directory of a project.</p> <p>It performs the following tasks: - Reads metadata from a <code>pyproject.toml</code> file located in the contrib submodule. - Creates a <code>README.md</code> file in the corresponding <code>docs/contrib/&lt;subdir&gt;</code> directory   with badges, metadata table, and links to individual module documentation. - Creates a separate Markdown file for each Python module (excluding <code>__init__.py</code>)   using the <code>:::</code> directive compatible with tools like <code>mkdocstrings</code>.</p> <p>This tool is intended to help automate documentation generation for modular contrib packages, especially in a monorepo-style structure.</p> <p>Requirements: - Python 3.11+ (uses <code>tomllib</code>), or - Python 3.6\u20133.10 with <code>tomli</code> installed (<code>pip install tomli</code>)</p> <p>La fonction read_pyproject_metadata retourne uniquement la section [project].</p> <p>Les auteurs sont format\u00e9s proprement si pr\u00e9sents en liste.</p> <p>Ce code utilise tomllib, dispo nativement \u00e0 partir de Python 3.11, ou pour Python 3.10 ou inf\u00e9rieur utilise tomli</p> <ul> <li>D\u00e9tecte dynamiquement la version de Python</li> <li>Utilise tomllib si dispo (Python 3.11+), sinon fallback sur tomli</li> <li>Inclut un message d\u2019erreur clair si tomli n\u2019est pas install\u00e9 en Python &lt; 3.11</li> </ul>"},{"location":"scripts/generate_contrib_docs/#scripts.generate_contrib_docs.generate_markdown_for_contrib","title":"<code>generate_markdown_for_contrib(module_name, contrib_dir='contrib', docs_dir='docs/contrib')</code>","text":"<p>Orchestrates the documentation generation for a contrib submodule.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>Name of the submodule inside contrib/.</p> required <code>contrib_dir</code> <code>str</code> <p>Path to the contrib source directory.</p> <code>'contrib'</code> <code>docs_dir</code> <code>str</code> <p>Path to the output documentation directory.</p> <code>'docs/contrib'</code> Source code in <code>scripts/generate_contrib_docs.py</code> <pre><code>def generate_markdown_for_contrib(module_name: str,\n                                  contrib_dir: str = \"contrib\",\n                                  docs_dir: str = \"docs/contrib\") -&gt; None:\n    \"\"\"\n    Orchestrates the documentation generation for a contrib submodule.\n\n    Args:\n        module_name (str): Name of the submodule inside contrib/.\n        contrib_dir (str): Path to the contrib source directory.\n        docs_dir (str): Path to the output documentation directory.\n    \"\"\"\n    subdir_path = os.path.join(contrib_dir, module_name)\n    docdir_path = os.path.join(docs_dir, module_name)\n\n    # Check if the target subdirectory exists\n    if not os.path.exists(subdir_path) or not os.path.isdir(subdir_path):\n        print(f\"The subdirectory '{module_name}' does not exist in '{contrib_dir}'.\")\n        return\n\n    # Ensure output directory exists\n    os.makedirs(docdir_path, exist_ok=True)\n\n    # Load metadata from pyproject.toml\n    metadata = read_pyproject_metadata(os.path.join(subdir_path, \"pyproject.toml\"))\n\n    # Generate .md files for each Python module\n    py_files = generate_python_file_docs(module_name, subdir_path, docdir_path)\n\n    # Generate the README.md summary\n    write_readme(module_name, docdir_path, metadata, py_files, subdir_path)\n</code></pre>"},{"location":"scripts/generate_contrib_docs/#scripts.generate_contrib_docs.generate_python_file_docs","title":"<code>generate_python_file_docs(module_name, subdir_path, docdir_path)</code>","text":"<p>Generates a Markdown documentation file for each Python module in the given subdirectory.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>The name of the contribution module (used in headings and paths).</p> required <code>subdir_path</code> <code>str</code> <p>Path to the source contrib directory.</p> required <code>docdir_path</code> <code>str</code> <p>Path where the Markdown documentation files will be written.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>List of Python module filenames (without .py extension) that were processed.</p> Source code in <code>scripts/generate_contrib_docs.py</code> <pre><code>def generate_python_file_docs(module_name: str, subdir_path: str, docdir_path: str) -&gt; list:\n    \"\"\"\n    Generates a Markdown documentation file for each Python module in the given subdirectory.\n\n    Args:\n        module_name (str): The name of the contribution module (used in headings and paths).\n        subdir_path (str): Path to the source contrib directory.\n        docdir_path (str): Path where the Markdown documentation files will be written.\n\n    Returns:\n        list: List of Python module filenames (without .py extension) that were processed.\n    \"\"\"\n    entries = []\n    for file in os.listdir(subdir_path):\n        if file.endswith(\".py\") and file != \"__init__.py\":\n            name = os.path.splitext(file)[0]\n            entries.append(name)\n\n            # Generate a Markdown file for each Python file\n            md_path = os.path.join(docdir_path, f\"{name}.md\")\n            with open(md_path, 'w', encoding='utf-8') as f:\n                f.write(f\"# {module_name}.{name}\\n\")\n                f.write(f\"::: contrib.{module_name}.{name}\\n\")\n                print(f\"Generated Markdown file: {md_path}\")\n    return entries\n</code></pre>"},{"location":"scripts/generate_contrib_docs/#scripts.generate_contrib_docs.write_readme","title":"<code>write_readme(module_name, docdir_path, metadata, py_files, subdir_path)</code>","text":"<p>Creates a README.md file summarizing the contrib module, its metadata, and links to individual module docs.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>The name of the contrib submodule.</p> required <code>docdir_path</code> <code>str</code> <p>Output path for the README.md file.</p> required <code>metadata</code> <code>Optional[dict]</code> <p>Metadata dictionary from pyproject.toml.</p> required <code>py_files</code> <code>list</code> <p>List of processed Python file names (no extensions).</p> required <code>subdir_path</code> <code>str</code> <p>Path to the original contrib source directory.</p> required Source code in <code>scripts/generate_contrib_docs.py</code> <pre><code>def write_readme(module_name: str, docdir_path: str, metadata: Optional[dict],\n                 py_files: list, subdir_path: str) -&gt; None:\n    \"\"\"\n    Creates a README.md file summarizing the contrib module, its metadata,\n    and links to individual module docs.\n\n    Args:\n        module_name (str): The name of the contrib submodule.\n        docdir_path (str): Output path for the README.md file.\n        metadata (Optional[dict]): Metadata dictionary from pyproject.toml.\n        py_files (list): List of processed Python file names (no extensions).\n        subdir_path (str): Path to the original contrib source directory.\n    \"\"\"\n    readme_path = os.path.join(docdir_path, \"README.md\")\n\n    with open(readme_path, 'w', encoding='utf-8') as md_file:\n        # Title and badges\n        md_file.write(f\"# {module_name}\\n\")\n        md_file.write(\"![pylint](./badges/pylint.svg)\")\n        md_file.write(\"![pytest](./badges/coverage.svg)\\n\\n\")\n\n        # Metadata table\n        if metadata:\n            md_file.write(\"| Key | Value |\\n|-----|-------|\\n\")\n            for key, value in metadata.items():\n                # Special formatting for authors list\n                if key == \"authors\" and isinstance(value, list):\n                    authors = \", \".join(a.get(\"name\", \"\") for a in value if isinstance(a, dict))\n                    md_file.write(f\"| {key} | {authors} |\\n\")\n                else:\n                    md_file.write(f\"| {key} | {value} |\\n\")\n        else:\n            md_file.write(f\"No pyproject.toml or [project] section found in {subdir_path}.\\n\")\n\n        md_file.write(\"\\n\" + \"-\" * 40 + \"\\n\")\n\n        # Links to individual module docs\n        for name in py_files:\n            md_file.write(f\"- [{name}](./{name}.md)\\n\")\n\n    print(f\"Generated Markdown file: {readme_path}\")\n</code></pre>"},{"location":"scripts/init_contrib/","title":"init_contrib","text":"<p>Script to initialize a new contribution by creating a folder with README.md and metadatas.yml files.</p>"},{"location":"scripts/init_contrib/#scripts.init_contrib.create_contribution","title":"<code>create_contribution(name)</code>","text":"<p>Create a new contribution directory with a README.md, metadatas.yml, init.py, code and tests files.</p> <p>Parameters: - name (str): The name of the contribution.</p> Source code in <code>scripts/init_contrib.py</code> <pre><code>def create_contribution(name):\n    \"\"\"\n    Create a new contribution directory with a README.md, metadatas.yml, __init__.py, code and tests files.\n\n    Parameters:\n    - name (str): The name of the contribution.\n    \"\"\"\n    contrib_root = './contrib'\n    contrib_path = os.path.join(contrib_root, name)\n\n    # Create the directory if it doesn't exist\n    os.makedirs(contrib_path, exist_ok=True)\n\n    # Create README.md\n    create_readme(contrib_path=contrib_path, name=name,description=name)\n\n    # Create metadatas.yml\n    write_pyproject_file(\n         contrib_path=contrib_path,\n         name=name,\n         metadata={\n            \"description\": name,\n         }\n    )\n\n    # Create __init__.py\n    create_init_py(contrib_path=contrib_path, name=name)\n\n    # Create CONTRIB_NAME.py\n    create_main_py(contrib_path=contrib_path, name=name)\n\n    # Create tests folder\n    create_tests_directory(contrib_path=contrib_path)\n\n    # Create tests environment config\n    create_conftest_file(contrib_path=contrib_path)\n\n    # Create tests/tests_CONTRIB_NAME.py\n    create_test_file(contrib_path=contrib_path, name=name)\n</code></pre>"},{"location":"scripts/init_contrib/#scripts.init_contrib.is_valid_contribution_name","title":"<code>is_valid_contribution_name(name)</code>","text":"<p>Validate the contribution name.</p> <p>The name must only contain lowercase letters, digits, and underscores.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The contribution name to validate.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the name is valid, False otherwise.</p> Source code in <code>scripts/init_contrib.py</code> <pre><code>def is_valid_contribution_name(name: str):\n    \"\"\"\n    Validate the contribution name.\n\n    The name must only contain lowercase letters, digits, and underscores.\n\n    Args:\n        name (str): The contribution name to validate.\n\n    Returns:\n        bool: True if the name is valid, False otherwise.\n    \"\"\"\n    return re.fullmatch(r'[a-z0-9_]+', name) is not None\n</code></pre>"},{"location":"scripts/init_contrib/#scripts.init_contrib.main","title":"<code>main()</code>","text":"<p>Main entry point of the script.</p> <p>Accepts the contribution name as a command-line argument, validates it, and creates the necessary files and directory structure in the 'contrib' folder.</p> Source code in <code>scripts/init_contrib.py</code> <pre><code>def main():\n    \"\"\"\n    Main entry point of the script.\n\n    Accepts the contribution name as a command-line argument, validates it, and creates\n    the necessary files and directory structure in the 'contrib' folder.\n    \"\"\"\n    if len(sys.argv) != 2:\n        print(\"Usage: python3 init.py &lt;contribution_name&gt;\")\n        sys.exit(1)\n\n    contrib_name = sys.argv[1].strip()\n\n    if not is_valid_contribution_name(contrib_name):\n        print(\n            \"Error: Contribution name must only contain lowercase letters, \"\n            \"digits, and underscores.\"\n        )\n        sys.exit(1)\n\n    create_contribution(contrib_name)\n</code></pre>"},{"location":"scripts/manage_contrib_list/","title":"manage_contrib_list","text":"<p>This script synchronizes the <code>docs/contrib</code> directory with the <code>contrib</code> directory.</p> <p>Steps: 1. List subdirectories in <code>contrib</code> and <code>docs/contrib</code>. 2. Remove subdirectories in <code>docs/contrib</code> that do not exist in <code>contrib</code>. 3. Display subdirectories in <code>contrib</code> that are missing in <code>docs/contrib</code>. 4. Generate an <code>index.md</code> file in <code>docs/contrib</code> with links to the <code>README.md</code> files    of valid subdirectories.</p> Example <p>If <code>contrib</code> contains: <pre><code>contrib/\n\u251c\u2500\u2500 folder1/\n\u251c\u2500\u2500 folder2/\n\u2514\u2500\u2500 folder3/\n</code></pre></p> <p>And <code>docs/contrib</code> contains: <pre><code>docs/contrib/\n\u251c\u2500\u2500 folder1/\n\u2502   \u2514\u2500\u2500 README.md\n\u251c\u2500\u2500 folder4/\n\u2502   \u2514\u2500\u2500 README.md\n</code></pre></p> <p>After execution: - <code>docs/contrib/folder4</code> will be removed. - <code>docs/contrib/index.md</code> will be generated with links to valid README.md files.</p>"},{"location":"scripts/manage_contrib_list/#scripts.manage_contrib_list.sync_contrib_docs","title":"<code>sync_contrib_docs()</code>","text":"<p>Synchronize the <code>docs/contrib</code> directory with the <code>contrib</code> directory.</p> Source code in <code>scripts/manage_contrib_list.py</code> <pre><code>def sync_contrib_docs():\n    \"\"\"\n    Synchronize the `docs/contrib` directory with the `contrib` directory.\n    \"\"\"\n    # List subdirectories in contrib and docs/contrib\n    contrib_dirs = list_subdirs(CONTRIB_DIR)\n    docs_contrib_dirs = list_subdirs(DOCS_CONTRIB_DIR)\n\n    print(\"Subdirectories in contrib:\")\n    print(contrib_dirs)\n\n    print(\"\\nSubdirectories in docs/contrib:\")\n    print(docs_contrib_dirs)\n\n    # Remove directories in docs/contrib that do not exist in contrib\n    obsolete_in_docs = docs_contrib_dirs - contrib_dirs\n    if not obsolete_in_docs:\n        print(\"\\nNo obsolete contrib in docs/contrib.\")\n    else:\n        for doc_dir in obsolete_in_docs:\n            doc_dir_path = os.path.join(DOCS_CONTRIB_DIR, doc_dir)\n            print(f\"Removing obsolete contrib: {doc_dir_path}\")\n            shutil.rmtree(doc_dir_path)\n\n    # List directories in contrib that do not exist in docs/contrib\n    missing_in_docs = contrib_dirs - docs_contrib_dirs\n    if not missing_in_docs:\n        print(\"\\nNo contrib missing in docs/contrib.\")\n    else:\n        print(f\"\\nContrib missing in docs/contrib:\\n{missing_in_docs}\")\n\n    # Generate the index.md file\n    os.makedirs(DOCS_CONTRIB_DIR, exist_ok=True)\n    index_path = os.path.join(DOCS_CONTRIB_DIR, 'index.md')\n    with open(index_path, 'w', encoding='utf-8') as index_file:\n        index_file.write(\"# Index of Contributions\\n\\n\")\n        for doc_dir in sorted(docs_contrib_dirs &amp; contrib_dirs):  # Only include valid directories\n            readme_path = os.path.join(DOCS_CONTRIB_DIR, doc_dir)\n            if os.path.exists(readme_path):\n                index_file.write(f\"- [{doc_dir}](./{doc_dir}/README.md)\\n\")\n\n    print(f\"\\nGenerated index file : {index_path}\")\n</code></pre>"},{"location":"scripts/utils/","title":"utils","text":"<p>utils.py - Utility functions for managing Ocean4DVarNet contributions</p> <p>This module provides helper functions to manage the initialization, validation, and documentation of contribution folders inside the <code>contrib/</code> directory. Each contribution typically contains:</p> <ul> <li>A <code>pyproject.toml</code> file with project metadata</li> <li>A main Python file named after the contribution</li> <li>A <code>README.md</code> file</li> <li>An <code>__init__.py</code> file</li> <li>A <code>tests/</code> subdirectory with a test file</li> </ul> <p>Key functionalities include: - Reading and validating <code>pyproject.toml</code> metadata - Automatically generating boilerplate files (<code>README.md</code>, <code>__init__.py</code>, etc.) - Synchronizing documentation folders (<code>docs/contrib/</code>) - Utility methods to check file/directory existence and list subfolders</p> <p>Constants: - <code>CONTRIB_DIR</code>: Root path for contributions - <code>DOCS_CONTRIB_DIR</code>: Root path for associated documentation</p> <p>This module assumes contributions follow a standardized structure and can be used in CLI scripts or tests to automate common tasks.</p> <p>Dependencies: - Python 3.11+ (for <code>tomllib</code>) - For Python 3.6\u20133.10, the <code>tomli</code> library is used as a fallback. Ensure it is installed:     <code>pip install tomli</code></p>"},{"location":"scripts/utils/#scripts.utils.conftest_file_exists","title":"<code>conftest_file_exists(contrib_path)</code>","text":"<p>Check if a test file with a specific name exists in the given directory.</p> <p>Parameters:</p> Name Type Description Default <code>contrib_path</code> <code>str</code> <p>The path to the directory where the test file is expected to be located.</p> required <code>name</code> <code>str</code> <p>The base name of the test file (without the \"test_\" prefix and \".py\" extension).</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the test file exists, False otherwise.</p> Source code in <code>scripts/utils.py</code> <pre><code>def conftest_file_exists(contrib_path: str) -&gt; bool:\n    \"\"\"\n    Check if a test file with a specific name exists in the given directory.\n\n    Args:\n        contrib_path (str): The path to the directory where the test file is expected to be located.\n        name (str): The base name of the test file (without the \"test_\" prefix and \".py\" extension).\n\n    Returns:\n        bool: True if the test file exists, False otherwise.\n    \"\"\"\n    return os.path.exists(os.path.join(contrib_path, 'conftest.py'))\n</code></pre>"},{"location":"scripts/utils/#scripts.utils.create_conftest_file","title":"<code>create_conftest_file(contrib_path)</code>","text":"<p>Creates a <code>conftest.py</code> file with the necessary configuration for pytest.</p> <p>This function writes a <code>conftest.py</code> file that ensures the root directory of the project is added to the PYTHONPATH, allowing the test suite to import modules from the <code>scripts</code> package.</p> <p>Parameters:</p> Name Type Description Default <code>contrib_path</code> <code>str</code> <p>The path to the contribution directory where the <code>tests/conftest.py</code> file will be created.</p> required <code>name</code> <code>str</code> <p>The name of the contribution, used for potential customization in the <code>conftest.py</code> file.</p> required Source code in <code>scripts/utils.py</code> <pre><code>def create_conftest_file(contrib_path: str) -&gt; None:\n    \"\"\"\n    Creates a `conftest.py` file with the necessary configuration for pytest.\n\n    This function writes a `conftest.py` file that ensures the root directory of the project is added\n    to the PYTHONPATH, allowing the test suite to import modules from the `scripts` package.\n\n    Args:\n        contrib_path (str): The path to the contribution directory where the `tests/conftest.py` file will be created.\n        name (str): The name of the contribution, used for potential customization in the `conftest.py` file.\n    \"\"\"\n\n    # Path to the conftest.py file to be created\n    conftest_path = os.path.join(contrib_path, 'tests', 'conftest.py')\n\n    # Content to be inserted into the file\n    content = '''\"\"\"\nPytest configuration file for the test suite.\n\nThis file ensures that the root directory of the project is added to the\nPYTHONPATH, allowing the test suite to import modules from the `scripts` package.\n\"\"\"\n\nimport sys\nimport os\n\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))\n'''\n\n    # Open the file in write mode (it will be created if it doesn't exist)\n    with open(conftest_path, 'w', encoding='utf-8') as f:\n        f.write(content)\n    print(f\"Created {conftest_path}\")\n</code></pre>"},{"location":"scripts/utils/#scripts.utils.create_init_py","title":"<code>create_init_py(contrib_path, name)</code>","text":"<p>Create an init.py file in the specified contribution directory.</p> <p>This function generates an init.py file in the given directory path and writes a simple docstring containing the provided name.</p> <p>Parameters:</p> Name Type Description Default <code>contrib_path</code> <code>str</code> <p>The path to the contribution directory where the init.py file will be created.</p> required <code>name</code> <code>str</code> <p>The name to include in the docstring of the init.py file.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scripts/utils.py</code> <pre><code>def create_init_py(contrib_path: str, name: str) -&gt; None:\n    \"\"\"\n    Create an __init__.py file in the specified contribution directory.\n\n    This function generates an __init__.py file in the given directory path\n    and writes a simple docstring containing the provided name.\n\n    Args:\n        contrib_path (str): The path to the contribution directory where the\n            __init__.py file will be created.\n        name (str): The name to include in the docstring of the __init__.py file.\n\n    Returns:\n        None\n    \"\"\"\n    init_py_path = os.path.join(contrib_path, '__init__.py')\n    with open(init_py_path, 'w', encoding='utf-8') as init_py_file:\n        init_py_file.write(f\"\\\"\\\"\\\" {name} \\\"\\\"\\\"\\n\")\n    print(f\"Created {init_py_path}\")\n</code></pre>"},{"location":"scripts/utils/#scripts.utils.create_main_py","title":"<code>create_main_py(contrib_path, name)</code>","text":"<p>Create a main Python file for a contribution.</p> <p>This function generates a Python file with the specified name in the given contribution path. The file will contain a basic docstring indicating it is part of the ocean4dvarnet contributions.</p> <p>Parameters:</p> Name Type Description Default <code>contrib_path</code> <code>str</code> <p>The directory path where the Python file will be created.</p> required <code>name</code> <code>str</code> <p>The name of the Python file (without the .py extension).</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scripts/utils.py</code> <pre><code>def create_main_py(contrib_path: str, name: str) -&gt; None:\n    \"\"\"\n    Create a main Python file for a contribution.\n\n    This function generates a Python file with the specified name in the given\n    contribution path. The file will contain a basic docstring indicating it\n    is part of the ocean4dvarnet contributions.\n\n    Args:\n        contrib_path (str): The directory path where the Python file will be created.\n        name (str): The name of the Python file (without the .py extension).\n\n    Returns:\n        None\n    \"\"\"\n    code_path = os.path.join(contrib_path, f\"{name}.py\")\n    # Content to be inserted into the file\n    content = f'''\"\"\"ocean4dvarnet contribution {name}\"\"\"\n\ndef hello_world():\n    \"\"\"A simple function that returns 'Hello, World!'\n\n    Returns:\n        str: The string 'Hello, World!'.\n    \"\"\"\n    return \"Hello, World!\"\n'''\n\n    with open(code_path, 'w', encoding='utf-8') as code_file:\n        code_file.write(content)\n    print(f\"Created {code_path}\")\n</code></pre>"},{"location":"scripts/utils/#scripts.utils.create_readme","title":"<code>create_readme(contrib_path, name, description='')</code>","text":"<p>Create a README.md file in the specified contribution directory.</p> <p>Parameters:</p> Name Type Description Default <code>contrib_path</code> <code>str</code> <p>The path to the contribution directory where the README.md file will be created.</p> required <code>name</code> <code>str</code> <p>The title to be written at the top of the README.md file.</p> required <code>description</code> <code>str</code> <p>An optional description to include in the  README.md file. Defaults to an empty string.</p> <code>''</code> Source code in <code>scripts/utils.py</code> <pre><code>def create_readme(contrib_path: str, name: str, description: str = \"\") -&gt; None:\n    \"\"\"\n    Create a README.md file in the specified contribution directory.\n\n    Args:\n        contrib_path (str): The path to the contribution directory where the README.md file will be created.\n        name (str): The title to be written at the top of the README.md file.\n        description (str, optional): An optional description to include in the \n            README.md file. Defaults to an empty string.\n    \"\"\"\n    readme_path = os.path.join(contrib_path, 'README.md')\n    with open(readme_path, 'w', encoding='utf-8') as readme_file:\n        readme_file.write(f\"# {name}\\n\")\n        if description:\n            readme_file.write(f\"{description}\")\n    print(f\"Created {readme_path}\")\n</code></pre>"},{"location":"scripts/utils/#scripts.utils.create_test_file","title":"<code>create_test_file(contrib_path, name)</code>","text":"<p>Create the test file for the contribution.</p> <p>Parameters:</p> Name Type Description Default <code>contrib_path</code> <code>str</code> <p>The path to the contribution directory where the test file will be created.</p> required <code>name</code> <code>str</code> <p>The name of the contribution, used to generate the test file name.</p> required Source code in <code>scripts/utils.py</code> <pre><code>def create_test_file(contrib_path: str, name: str) -&gt; None:\n    \"\"\"\n    Create the test file for the contribution.\n\n    Args:\n        contrib_path (str): The path to the contribution directory where the test file will be created.\n        name (str): The name of the contribution, used to generate the test file name.\n    \"\"\"\n    test_path = os.path.join(contrib_path, 'tests', f\"test_{name}.py\")\n    # Content to be inserted into the file\n    content = f'''\"\"\"Unit tests for contribution {name}\"\"\"\n\nfrom {name} import hello_world\n\ndef test_hello_world():\n    assert hello_world() == \"Hello, World!\"\n'''\n\n    with open(test_path, 'w', encoding='utf-8') as test_file:\n        test_file.write(content)\n    print(f\"Created {test_path}\")\n</code></pre>"},{"location":"scripts/utils/#scripts.utils.create_tests_directory","title":"<code>create_tests_directory(contrib_path)</code>","text":"<p>Creates a 'tests' directory inside the specified contribution directory.</p> <p>Parameters:</p> Name Type Description Default <code>contrib_path</code> <code>str</code> <p>The path to the contribution directory where the 'tests' directory will be created.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The path to the created 'tests' directory.</p> Notes <p>If the 'tests' directory already exists, this function will not raise an error.</p> Source code in <code>scripts/utils.py</code> <pre><code>def create_tests_directory(contrib_path: str) -&gt; str:\n    \"\"\"\n    Creates a 'tests' directory inside the specified contribution directory.\n\n    Args:\n        contrib_path (str): The path to the contribution directory where the 'tests' directory will be created.\n\n    Returns:\n        str: The path to the created 'tests' directory.\n\n    Notes:\n        If the 'tests' directory already exists, this function will not raise an error.\n    \"\"\"\n    tests_path = os.path.join(contrib_path, 'tests')\n    os.makedirs(tests_path, exist_ok=True)\n    print(f\"Created {tests_path}/\")\n</code></pre>"},{"location":"scripts/utils/#scripts.utils.init_py_exists","title":"<code>init_py_exists(contrib_path)</code>","text":"<p>Checks if an 'init.py' file exists in the specified directory.</p> <p>Parameters:</p> Name Type Description Default <code>contrib_path</code> <code>str</code> <p>The path to the directory to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the 'init.py' file exists in the directory, False otherwise.</p> Source code in <code>scripts/utils.py</code> <pre><code>def init_py_exists(contrib_path: str) -&gt; bool:\n    \"\"\"\n    Checks if an '__init__.py' file exists in the specified directory.\n\n    Args:\n        contrib_path (str): The path to the directory to check.\n\n    Returns:\n        bool: True if the '__init__.py' file exists in the directory, False otherwise.\n    \"\"\"\n    return os.path.exists(os.path.join(contrib_path, '__init__.py'))\n</code></pre>"},{"location":"scripts/utils/#scripts.utils.list_directories","title":"<code>list_directories(path)</code>","text":"<p>List all subdirectories in the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The directory path to list subdirectories from.</p> required <p>Returns:</p> Name Type Description <code>set</code> <p>A set of subdirectory names.</p> Source code in <code>scripts/utils.py</code> <pre><code>def list_directories(path):\n    \"\"\"\n    List all subdirectories in the given path.\n\n    Args:\n        path (str): The directory path to list subdirectories from.\n\n    Returns:\n        set: A set of subdirectory names.\n\n    \"\"\"\n    if not os.path.exists(path):\n        return set()\n    return {name for name in os.listdir(path) if os.path.isdir(os.path.join(path, name))}\n</code></pre>"},{"location":"scripts/utils/#scripts.utils.list_subdirs","title":"<code>list_subdirs(path)</code>","text":"<p>List all subdirectories in the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The directory path to list subdirectories from.</p> required <p>Returns:</p> Name Type Description <code>set</code> <p>A set of subdirectory names.</p> Source code in <code>scripts/utils.py</code> <pre><code>def list_subdirs(path):\n    \"\"\"\n    List all subdirectories in the given path.\n\n    Args:\n        path (str): The directory path to list subdirectories from.\n\n    Returns:\n        set: A set of subdirectory names.\n\n    \"\"\"\n    if not os.path.exists(path):\n        return set()\n    return {name for name in os.listdir(path) if os.path.isdir(os.path.join(path, name))}\n</code></pre>"},{"location":"scripts/utils/#scripts.utils.main_py_exists","title":"<code>main_py_exists(contrib_path, name)</code>","text":"<p>Checks if a Python file with the specified name exists in the given directory.</p> <p>Parameters:</p> Name Type Description Default <code>contrib_path</code> <code>str</code> <p>The path to the directory where the file is expected to be located.</p> required <code>name</code> <code>str</code> <p>The name of the Python file (without the .py extension).</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the file exists, False otherwise.</p> Source code in <code>scripts/utils.py</code> <pre><code>def main_py_exists(contrib_path: str, name: str) -&gt; bool:\n    \"\"\"\n    Checks if a Python file with the specified name exists in the given directory.\n\n    Args:\n        contrib_path (str): The path to the directory where the file is expected to be located.\n        name (str): The name of the Python file (without the .py extension).\n\n    Returns:\n        bool: True if the file exists, False otherwise.\n    \"\"\"\n    return os.path.exists(os.path.join(contrib_path, f\"{name}.py\"))\n</code></pre>"},{"location":"scripts/utils/#scripts.utils.pyproject_file_exists","title":"<code>pyproject_file_exists(contrib_path)</code>","text":"<p>Checks if a 'pyproject.toml' file exists in the specified directory.</p> <p>Parameters:</p> Name Type Description Default <code>contrib_path</code> <code>str</code> <p>The path to the directory where the function will look for the 'pyproject.toml' file.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the 'pyproject.toml' file exists in the specified directory, False otherwise.</p> Source code in <code>scripts/utils.py</code> <pre><code>def pyproject_file_exists(contrib_path: str) -&gt; bool:\n    \"\"\"\n    Checks if a 'pyproject.toml' file exists in the specified directory.\n\n    Args:\n        contrib_path (str): The path to the directory where the function will look for the 'pyproject.toml' file.\n\n    Returns:\n        bool: True if the 'pyproject.toml' file exists in the specified directory, False otherwise.\n    \"\"\"\n    return os.path.exists(os.path.join(contrib_path, 'pyproject.toml'))\n</code></pre>"},{"location":"scripts/utils/#scripts.utils.read_pyproject_metadata","title":"<code>read_pyproject_metadata(pyproject_path)</code>","text":"<p>Reads a pyproject.toml file and extracts the [project] section.</p> <p>Parameters:</p> Name Type Description Default <code>pyproject_path</code> <code>str</code> <p>Path to the pyproject.toml file.</p> required <p>Returns:</p> Type Description <code>Optional[dict]</code> <p>Optional[dict]: A dictionary containing metadata from the [project] section,             or None if the file or section is missing.</p> Source code in <code>scripts/utils.py</code> <pre><code>def read_pyproject_metadata(pyproject_path: str) -&gt; Optional[dict]:\n    \"\"\"\n    Reads a pyproject.toml file and extracts the [project] section.\n\n    Args:\n        pyproject_path (str): Path to the pyproject.toml file.\n\n    Returns:\n        Optional[dict]: A dictionary containing metadata from the [project] section,\n                        or None if the file or section is missing.\n    \"\"\"\n    if not os.path.exists(pyproject_path):\n        return None\n\n    with open(pyproject_path, 'rb') as f:\n        data = tomllib.load(f)\n\n    return data.get(\"project\")\n</code></pre>"},{"location":"scripts/utils/#scripts.utils.readme_exists","title":"<code>readme_exists(contrib_path)</code>","text":"<p>Checks if a README.md file exists in the specified directory.</p> <p>Parameters:</p> Name Type Description Default <code>contrib_path</code> <code>str</code> <p>The path to the directory where the README.md file is expected.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the README.md file exists in the specified directory, False otherwise.</p> Source code in <code>scripts/utils.py</code> <pre><code>def readme_exists(contrib_path: str) -&gt; bool:\n    \"\"\"\n    Checks if a README.md file exists in the specified directory.\n\n    Args:\n        contrib_path (str): The path to the directory where the README.md file is expected.\n\n    Returns:\n        bool: True if the README.md file exists in the specified directory, False otherwise.\n    \"\"\"\n    return os.path.exists(os.path.join(contrib_path, 'README.md'))\n</code></pre>"},{"location":"scripts/utils/#scripts.utils.sync_contrib_docs","title":"<code>sync_contrib_docs()</code>","text":"<p>Synchronize the <code>docs/contrib</code> directory with the <code>contrib</code> directory.</p> Source code in <code>scripts/utils.py</code> <pre><code>def sync_contrib_docs():\n    \"\"\"\n    Synchronize the `docs/contrib` directory with the `contrib` directory.\n    \"\"\"\n    # List subdirectories in contrib and docs/contrib\n    contrib_dirs = list_directories(CONTRIB_DIR)\n    docs_contrib_dirs = list_directories(DOCS_CONTRIB_DIR)\n\n    print(\"Subdirectories in contrib:\")\n    print(contrib_dirs)\n\n    print(\"\\nSubdirectories in docs/contrib:\")\n    print(docs_contrib_dirs)\n\n    # Remove directories in docs/contrib that do not exist in contrib\n    for doc_dir in docs_contrib_dirs - contrib_dirs:\n        doc_dir_path = os.path.join(DOCS_CONTRIB_DIR, doc_dir)\n        print(f\"Removing obsolete directory: {doc_dir_path}\")\n        shutil.rmtree(doc_dir_path)\n\n    # List directories in contrib that do not exist in docs/contrib\n    missing_in_docs = contrib_dirs - docs_contrib_dirs\n    print(\"\\nDirectories in contrib missing in docs/contrib:\")\n    print(missing_in_docs)\n</code></pre>"},{"location":"scripts/utils/#scripts.utils.test_file_exists","title":"<code>test_file_exists(contrib_path, name)</code>","text":"<p>Check if a test file with a specific name exists in the given directory.</p> <p>Parameters:</p> Name Type Description Default <code>contrib_path</code> <code>str</code> <p>The path to the directory where the test file is expected to be located.</p> required <code>name</code> <code>str</code> <p>The base name of the test file (without the \"test_\" prefix and \".py\" extension).</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the test file exists, False otherwise.</p> Source code in <code>scripts/utils.py</code> <pre><code>def test_file_exists(contrib_path: str, name: str) -&gt; bool:\n    \"\"\"\n    Check if a test file with a specific name exists in the given directory.\n\n    Args:\n        contrib_path (str): The path to the directory where the test file is expected to be located.\n        name (str): The base name of the test file (without the \"test_\" prefix and \".py\" extension).\n\n    Returns:\n        bool: True if the test file exists, False otherwise.\n    \"\"\"\n    return os.path.exists(os.path.join(contrib_path, f\"test_{name}.py\"))\n</code></pre>"},{"location":"scripts/utils/#scripts.utils.validate_contrib_metadata","title":"<code>validate_contrib_metadata(contrib_name, base_path=CONTRIB_DIR)</code>","text":"<p>Validate the pyproject.toml metadata for a given contribution.</p> <p>Parameters:</p> Name Type Description Default <code>contrib_name</code> <code>str</code> <p>Name of the contribution folder.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if metadata is valid, False otherwise.</p> Source code in <code>scripts/utils.py</code> <pre><code>def validate_contrib_metadata(contrib_name: str, base_path: str = CONTRIB_DIR) -&gt; bool:\n    \"\"\"\n    Validate the pyproject.toml metadata for a given contribution.\n\n    Args:\n        contrib_name (str): Name of the contribution folder.\n\n    Returns:\n        bool: True if metadata is valid, False otherwise.\n    \"\"\"\n    pyproject_path = os.path.join(base_path, contrib_name, \"pyproject.toml\")\n    metadata = read_pyproject_metadata(pyproject_path)\n\n    if metadata is None:\n        print(f\"Missing or invalid pyproject.toml in {contrib_name}\")\n        return False\n\n    missing_fields = [field for field in REQUIRED_FIELDS if field not in metadata]\n\n    if missing_fields:\n        print(f\"Missing required fields in {contrib_name}: {', '.join(missing_fields)}\")\n        return False\n\n    print(f\"Metadata for {contrib_name} is valid.\")\n    return True\n</code></pre>"},{"location":"scripts/utils/#scripts.utils.write_pyproject_file","title":"<code>write_pyproject_file(contrib_path, name, metadata=None)</code>","text":"<p>Generate a <code>pyproject.toml</code> file with customizable metadata for a Python project.</p> <p>This function creates a <code>pyproject.toml</code> file in the specified directory with the provided project metadata, including name, description, version, license, author information, and dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>contrib_path</code> <code>str</code> <p>The directory path where the <code>pyproject.toml</code> file will be created.</p> required <code>name</code> <code>str</code> <p>The name of the project. This will also be used as the default description if none is provided.</p> required <code>metadata</code> <code>dict</code> <p>A dictionary containing project metadata, such as: - description (str): A brief description of the project. - version (str): The version of the project. - license (str): The license type or text for the project. - author_name (str): The name of the author. - author_email (str): The email address of the author. - dependencies (list[str]): A list of project dependencies.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>This function does not return a value. It writes the <code>pyproject.toml</code> file to the specified directory.</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If there is an issue writing the file to the specified directory.</p> Example <p>write_pyproject_file(     contrib_path=\"/path/to/project\",     name=\"my_project\",     metadata={         \"description\": \"A sample Python project\",         \"version\": \"0.1.0\",         \"license\": \"MIT\",         \"author_name\": \"John Doe\",         \"author_email\": \"john.doe@example.com\",         \"dependencies\": [\"numpy\", \"pandas\"]     } )</p> Source code in <code>scripts/utils.py</code> <pre><code>def write_pyproject_file(\n    contrib_path: str,\n    name: str,\n    metadata: Optional[dict] = None\n) -&gt; None:\n    \"\"\"\n    Generate a `pyproject.toml` file with customizable metadata for a Python project.\n\n    This function creates a `pyproject.toml` file in the specified directory with\n    the provided project metadata, including name, description, version, license,\n    author information, and dependencies.\n\n    Args:\n        contrib_path (str): The directory path where the `pyproject.toml` file will be created.\n        name (str): The name of the project. This will also be used as the default description if none is provided.\n        metadata (dict, optional): A dictionary containing project metadata, such as:\n            - description (str): A brief description of the project.\n            - version (str): The version of the project.\n            - license (str): The license type or text for the project.\n            - author_name (str): The name of the author.\n            - author_email (str): The email address of the author.\n            - dependencies (list[str]): A list of project dependencies.\n\n    Returns:\n        None: This function does not return a value. It writes the `pyproject.toml` file to the specified directory.\n\n    Raises:\n        OSError: If there is an issue writing the file to the specified directory.\n\n    Example:\n        write_pyproject_file(\n            contrib_path=\"/path/to/project\",\n            name=\"my_project\",\n            metadata={\n                \"description\": \"A sample Python project\",\n                \"version\": \"0.1.0\",\n                \"license\": \"MIT\",\n                \"author_name\": \"John Doe\",\n                \"author_email\": \"john.doe@example.com\",\n                \"dependencies\": [\"numpy\", \"pandas\"]\n            }\n        )\n    \"\"\"\n    metadata = metadata or {}\n    description = metadata.get(\"description\", name)\n    version = metadata.get(\"version\", \"1.0.0\")\n    license_str = metadata.get(\"license\", \"CeCILL-C FREE SOFTWARE LICENSE AGREEMENT\")\n    author_name = metadata.get(\"author_name\", \"Contributor Name\")\n    author_email = metadata.get(\"author_email\", \"contributor1@example.com\")\n    dependencies = metadata.get(\"dependencies\", [])\n\n    pyproject_toml_file_path = os.path.join(contrib_path, 'pyproject.toml')\n    if dependencies:\n        deps_str = \"\\n\".join([f'\"{dep}\",' for dep in dependencies])\n        deps_section = f\" [\\n{deps_str}\\n]\"\n    else:\n        deps_section = \" []\"\n\n    content = f\"\"\"[project]\nname = \"{name}\"\ndescription = \"{description}\"\nversion = \"{version}\"\nlicense = \"{license_str}\"\nauthors = [{{ name = \"{author_name}\", email = \"{author_email}\" }}]\ndependencies = {deps_section}\n\"\"\"\n\n    with open(pyproject_toml_file_path, 'w', encoding='utf-8') as f:\n        f.write(content)\n    print(f\"Created {pyproject_toml_file_path}\")\n</code></pre>"}]}